diff --git a/tools/qemu-xen/cpu-all.h b/tools/qemu-xen/cpu-all.h
index c9c51b8..cc70228 100644
--- a/tools/qemu-xen/cpu-all.h
+++ b/tools/qemu-xen/cpu-all.h
@@ -476,6 +476,10 @@ hwaddr cpu_get_phys_page_debug(CPUArchState *env, target_ulong addr);
 
 extern int phys_ram_fd;
 extern ram_addr_t ram_size;
+extern int vgt_low_gm_sz;
+extern int vgt_high_gm_sz;
+extern int vgt_fence_sz;
+extern const char *vgt_monitor_config_file;
 
 /* RAM is pre-allocated and passed into qemu_ram_alloc_from_ptr */
 #define RAM_PREALLOC_MASK   (1 << 0)
diff --git a/tools/qemu-xen/hw/Makefile.objs b/tools/qemu-xen/hw/Makefile.objs
index d581d8d..e2506ca 100644
--- a/tools/qemu-xen/hw/Makefile.objs
+++ b/tools/qemu-xen/hw/Makefile.objs
@@ -133,6 +133,7 @@ common-obj-$(CONFIG_VGA_ISA_MM) += vga-isa-mm.o
 common-obj-$(CONFIG_VMWARE_VGA) += vmware_vga.o
 common-obj-$(CONFIG_VMMOUSE) += vmmouse.o
 common-obj-$(CONFIG_VGA_CIRRUS) += cirrus_vga.o
+common-obj-y += vga-xengt.o
 
 common-obj-$(CONFIG_RC4030) += rc4030.o
 common-obj-$(CONFIG_DP8393X) += dp8393x.o
diff --git a/tools/qemu-xen/hw/i386/Makefile.objs b/tools/qemu-xen/hw/i386/Makefile.objs
index 0d3f6a8..d890e7d 100644
--- a/tools/qemu-xen/hw/i386/Makefile.objs
+++ b/tools/qemu-xen/hw/i386/Makefile.objs
@@ -9,7 +9,7 @@ obj-y += pc_sysfw.o
 obj-y += lpc_ich9.o q35.o pc_q35.o
 obj-$(CONFIG_XEN) += xen_platform.o xen_apic.o
 obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen-host-pci-device.o
-obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen_pt.o xen_pt_config_init.o xen_pt_msi.o
+obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen_pt.o xen_pt_config_init.o xen_pt_msi.o xen_pt_igd.o
 obj-y += kvm/
 obj-$(CONFIG_SPICE) += qxl.o qxl-logger.o qxl-render.o
 
diff --git a/tools/qemu-xen/hw/pc_piix.c b/tools/qemu-xen/hw/pc_piix.c
index aa3e7f4..904c82c 100644
--- a/tools/qemu-xen/hw/pc_piix.c
+++ b/tools/qemu-xen/hw/pc_piix.c
@@ -46,8 +46,11 @@
 #include "cpu.h"
 #ifdef CONFIG_XEN
 #  include <xen/hvm/hvm_info_table.h>
+#  include "vga-xengt.h"
+#endif
+#ifdef CONFIG_XEN_PCI_PASSTHROUGH
+#include "xen_pt.h"
 #endif
-
 #define MAX_IDE_BUS 2
 
 static const int ide_iobase[MAX_IDE_BUS] = { 0x1f0, 0x170 };
@@ -92,9 +95,9 @@ static void pc_init1(MemoryRegion *system_memory,
         kvmclock_create();
     }
 
-    if (ram_size >= 0xe0000000 ) {
-        above_4g_mem_size = ram_size - 0xe0000000;
-        below_4g_mem_size = 0xe0000000;
+    if (ram_size >= 0xc0000000) {
+        above_4g_mem_size = ram_size - 0xc0000000;
+        below_4g_mem_size = 0xc0000000;
     } else {
         above_4g_mem_size = 0;
         below_4g_mem_size = ram_size;
@@ -162,7 +165,32 @@ static void pc_init1(MemoryRegion *system_memory,
 
     pc_register_ferr_irq(gsi[13]);
 
-    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);
+    /*
+     * Initialize XenGT hooks before normal VGA init. The
+     * ideal case is to have IGD presented as the primary
+     * graphics card in 00:02.0, and then have other emulated
+     * PCI VGA card all disabled. We still rely on Qemu to
+     * emulate legacy ISA ports, so requires the ISA vga logic.
+     */
+    if (xengt_vga_enabled && pci_enabled) {
+        xengt_vga_init(pci_bus);
+        isa_create_simple(isa_bus, "isa-vga");
+    } else if (gfx_passthru) {
+        /*
+         * Do not create emulated VGA card here.
+         * and wait QEMU create qdev: xen-pci-passthrough,
+         * which is a pass-throughed IGD device.
+         * 
+         * We need a dummy graphic console here.
+         * otherwise QEMU will not have a vaild console,
+         * and we have to passthrough mouse and keyboard
+         * to control VM.
+         */
+        graphic_console_init(NULL, NULL, NULL, NULL, NULL);
+    } else {
+        pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);
+    }
+
     if (xen_enabled()) {
         pci_create_simple(pci_bus, -1, "xen-platform");
     }
diff --git a/tools/qemu-xen/hw/pci.c b/tools/qemu-xen/hw/pci.c
index 97a0cd7..3c9e1a6 100644
--- a/tools/qemu-xen/hw/pci.c
+++ b/tools/qemu-xen/hw/pci.c
@@ -34,6 +34,7 @@
 #include "msi.h"
 #include "msix.h"
 #include "exec-memory.h"
+#include "xen_pt.h"
 
 //#define DEBUG_PCI
 #ifdef DEBUG_PCI
@@ -768,6 +769,11 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, PCIBus *bus,
     if (devfn < 0) {
         for(devfn = bus->devfn_min ; devfn < ARRAY_SIZE(bus->devices);
             devfn += PCI_FUNC_MAX) {
+
+            /* If vGT/XenGT is in use, reserve 00:02.* for the IGD */
+            if ((xengt_vga_enabled || gfx_passthru) && devfn == 0x10)
+                continue; 
+
             if (!bus->devices[devfn])
                 goto found;
         }
@@ -799,6 +805,7 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, PCIBus *bus,
     pci_dev->irq_state = 0;
     pci_config_alloc(pci_dev);
 
+    printf("set vendor id(%x) for devfn(%x)\n", pc->vendor_id, devfn);
     pci_config_set_vendor_id(pci_dev->config, pc->vendor_id);
     pci_config_set_device_id(pci_dev->config, pc->device_id);
     pci_config_set_revision(pci_dev->config, pc->revision);
diff --git a/tools/qemu-xen/hw/pci.h b/tools/qemu-xen/hw/pci.h
index 4da0c2a..d32a58f 100644
--- a/tools/qemu-xen/hw/pci.h
+++ b/tools/qemu-xen/hw/pci.h
@@ -102,6 +102,8 @@ typedef struct PCIIORegion {
 
 #include "pci_regs.h"
 
+#define PCI_INTEL_OPREGION 0xfc
+
 /* PCI HEADER_TYPE */
 #define  PCI_HEADER_TYPE_MULTI_FUNCTION 0x80
 
diff --git a/tools/qemu-xen/hw/piix_pci.c b/tools/qemu-xen/hw/piix_pci.c
index ba1b3de..27f7c56 100644
--- a/tools/qemu-xen/hw/piix_pci.c
+++ b/tools/qemu-xen/hw/piix_pci.c
@@ -31,6 +31,13 @@
 #include "range.h"
 #include "xen.h"
 #include "pam.h"
+#include "sysemu.h"
+#ifdef CONFIG_XEN
+#include "vga-xengt.h"
+#endif
+#ifdef CONFIG_XEN_PCI_PASSTHROUGH
+#include "xen_pt.h"
+#endif
 
 /*
  * I440FX chipset data sheet.
@@ -136,6 +143,8 @@ static void i440fx_write_config(PCIDevice *dev,
         range_covers_byte(address, len, I440FX_SMRAM)) {
         i440fx_update_memory_mappings(d);
     }
+
+    vgt_bridge_pci_write(dev, address, val, len);
 }
 
 static int i440fx_load_old(QEMUFile* f, void *opaque, int version_id)
@@ -204,6 +213,11 @@ static int i440fx_initfn(PCIDevice *dev)
     d->dev.config[I440FX_SMRAM] = 0x02;
 
     cpu_smm_register(&i440fx_set_smm, d);
+
+    if (xengt_vga_enabled) {
+        vgt_bridge_pci_conf_init(dev);
+    }
+
     return 0;
 }
 
@@ -296,6 +310,14 @@ static PCIBus *i440fx_common_init(const char *device_name,
 
     i440fx_update_memory_mappings(f);
 
+#if CONFIG_XEN_PCI_PASSTHROUGH
+    if (gfx_passthru) {
+        d->config_read = igd_pci_read;
+        d->config_write = igd_pci_write;
+        intel_pch_init(b);
+    }
+#endif
+
     return b;
 }
 
@@ -547,6 +569,10 @@ static void i440fx_class_init(ObjectClass *klass, void *data)
     dc->desc = "Host bridge";
     dc->no_user = 1;
     dc->vmsd = &vmstate_i440fx;
+    if (xengt_vga_enabled) {
+        k->config_read = vgt_bridge_pci_read;
+    }
+
 }
 
 static const TypeInfo i440fx_info = {
diff --git a/tools/qemu-xen/hw/vga-xengt.c b/tools/qemu-xen/hw/vga-xengt.c
new file mode 100644
index 0000000..e5bafa9
--- /dev/null
+++ b/tools/qemu-xen/hw/vga-xengt.c
@@ -0,0 +1,638 @@
+/*
+ * QEMU vGT/XenGT Legacy VGA support
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) Citrix Systems, Inc
+ * Copyright (c) Intel
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include "hw.h"
+#include "console.h"
+#include "pc.h"
+#include "pci.h"
+#include "pci_host.h"
+#include "pci_bridge.h"
+#include "pci_internals.h"
+#include "vga_int.h"
+#include "pixel_ops.h"
+#include "qemu-timer.h"
+#include "loader.h"
+#include "xen_pt.h"
+#include "vga-xengt.h"
+#include "qemu-log.h"
+
+typedef struct vgt_vga_state {
+    PCIDevice dev;
+    struct VGACommonState state;
+    int num_displays;
+    XenHostPCIDevice host_dev;
+    bool instance_created;
+} vgt_vga_state_t;
+
+#define EDID_SIZE 128
+#define MAX_INPUT_NUM 3
+#define MAX_FILE_NAME_LENGTH 128
+
+/* port definition must align with gvt-g driver */
+enum vgt_port {
+    PORT_A = 0,
+    PORT_B,
+    PORT_C,
+    PORT_D,
+    PORT_E,
+    MAX_PORTS
+};
+
+typedef struct vgt_monitor_info {
+    unsigned char port_type:4;
+    unsigned char port_is_dp:4;  /* 0 = HDMI PORT, 1 = DP port, only valid for PORT_B/C/D */
+    unsigned char port_override;
+    unsigned char edid[EDID_SIZE];
+}vgt_monitor_info_t;
+
+/* These are the default values */
+int vgt_low_gm_sz = 64; /* in MB */
+int vgt_high_gm_sz = 448; /* in MB */
+int vgt_fence_sz = 4;
+int vgt_primary = 1; /* -1 means "not specified */
+const char *vgt_monitor_config_file = NULL;
+
+
+static inline unsigned int port_info_to_type(unsigned char port_is_dp, int port)
+{
+    /* port type definition must align with gvt-g driver */
+    enum vgt_port_type {
+        VGT_CRT = 0,
+        VGT_DP_A,
+        VGT_DP_B,
+        VGT_DP_C,
+        VGT_DP_D,
+        VGT_HDMI_B,
+        VGT_HDMI_C,
+        VGT_HDMI_D,
+        VGT_PORT_TYPE_MAX
+    } ret;
+
+    switch (port) {
+        case PORT_A:
+            ret = VGT_DP_A;
+            break;
+        case PORT_B:
+            ret = (port_is_dp) ? VGT_DP_B : VGT_HDMI_B;
+            break;
+        case PORT_C:
+            ret = (port_is_dp) ? VGT_DP_C : VGT_HDMI_C;
+            break;
+        case PORT_D:
+            ret = (port_is_dp) ? VGT_DP_D : VGT_HDMI_D;
+            break;
+	case PORT_E:
+            ret = VGT_CRT;
+            break;
+        default:
+            ret = VGT_PORT_TYPE_MAX;
+            break;
+    }
+
+    return ret;
+}
+
+static bool validate_monitor_configs(vgt_monitor_info_t *config)
+{
+    if (config->port_type >= MAX_PORTS) {
+        qemu_log("vGT: %s failed because the invalid port_type input: %d!\n",
+            __func__, config->port_type);
+        return false;
+    }
+    if (config->port_override >= MAX_PORTS) {
+        qemu_log("vGT: %s failed due to the invalid port_override input: %d!\n",
+            __func__, config->port_override);
+        return false;
+    }
+    if (config->edid[126] != 0) {
+        qemu_log("vGT: %s failed because there is extended block in EDID! "
+            "(EDID[126] is not zero)\n", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+static void config_hvm_monitors(vgt_monitor_info_t *config)
+{
+    const char *path_prefix = "/sys/kernel/vgt/vm";
+    FILE *fp;
+    char file_name[MAX_FILE_NAME_LENGTH];
+    int ret;
+
+    // override
+    snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/port_override",
+        path_prefix, xen_domid, 'A' + config->port_type);
+    if ((fp = fopen(file_name, "w")) == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+            __func__, file_name, errno);
+        return;
+    }
+    fprintf(fp, "PORT_%c", 'A' + config->port_override);
+    if (fclose(fp) != 0) {
+        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+    }
+
+    // type
+    snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/type",
+        path_prefix, xen_domid, 'A' + config->port_type);
+    if ((fp = fopen(file_name, "w")) == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+            __func__, file_name, errno);
+        return;
+    }
+    fprintf(fp, "%d", port_info_to_type(config->port_is_dp, config->port_type));
+    if (fclose(fp) != 0) {
+        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+    }
+
+    // edid
+    snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/edid",
+        path_prefix, xen_domid, 'A' + config->port_type);
+    if ((fp = fopen(file_name, "w")) == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+            __func__, file_name, errno);
+        return;
+    }
+    ret = fwrite(config->edid, 1, EDID_SIZE, fp);
+    if (ret != EDID_SIZE) {
+        qemu_log("vGT: %s failed to write EDID with returned size %d: "
+            "errno = %d\n", __func__, ret, errno);
+    }
+    if (fclose(fp) != 0) {
+        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+    }
+
+    // flush result to port structure
+    snprintf(file_name, MAX_FILE_NAME_LENGTH, "%s%d/PORT_%c/connection",
+        path_prefix, xen_domid, 'A' + config->port_type);
+    if ((fp = fopen(file_name, "w")) == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+            __func__, file_name, errno);
+        return;
+    }
+    fprintf(fp, "flush");
+    if (fclose(fp) != 0) {
+        qemu_log("vGT: %s failed to close file: errno = %d\n", __func__, errno);
+    }
+}
+
+#define CTOI(chr) \
+    (chr >= '0' && chr <= '9' ? chr - '0' : \
+    (chr >= 'a' && chr <= 'f' ? chr - 'a' + 10 :\
+    (chr >= 'A' && chr <= 'F' ? chr - 'A' + 10 : -1)))
+
+static int get_byte_from_txt_file(FILE *file, const char *file_name)
+{
+    int i;
+    int val[2];
+
+    for (i = 0; i < 2; ++ i) {
+        do {
+            unsigned char buf;
+            if (fread(&buf, 1, 1, file) != 1) {
+                qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
+                    __func__, file_name, errno);
+                return -1;
+            }
+
+            if (buf == '#') {
+                // ignore comments
+                int ret;
+                while (((ret = fread(&buf, 1, 1, file)) == 1) && (buf != '\n')) ;
+                if (ret != 1) {
+                    qemu_log("vGT: %s failed to proceed after comment string "
+                            "from text file %s with errno: %d!\n",
+                            __func__, file_name, errno);
+                    return -1;
+                }
+            }
+
+            val[i] = CTOI(buf);
+        } while (val[i] == -1);
+    }
+
+    return ((val[0] << 4) | val[1]);
+}
+
+static int get_config_header(unsigned char *buf, FILE *file, const char *file_name)
+{
+    int ret;
+    unsigned char chr;
+
+    if (fread(&chr, 1, 1, file) != 1) {
+        qemu_log("vGT: %s failed to get byte from text file %s with errno: %d!\n",
+            __func__, file_name, errno);
+        return -1;
+    }
+
+    if (chr == '#') {
+        // it is text format input.
+        while (((ret = fread(&chr, 1, 1, file)) == 1) && (chr != '\n')) ;
+        if (ret != 1) {
+            qemu_log("vGT: %s failed to proceed after comment string "
+                "from file %s with errno: %d!\n",
+                __func__, file_name, errno);
+            return -1;
+        }
+        ret = get_byte_from_txt_file(file, file_name);
+        buf[0] = 1;
+        buf[1] = (ret & 0xf);
+    } else {
+        if ((ret = fread(&buf[0], 1, 2, file)) != 2) {
+            qemu_log("vGT: %s failed to read file %s! "
+                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
+                __func__, file_name, 2, ret, errno);
+            return -1;
+        }
+
+        if (buf[0] != 0) {
+            // it is text format input.
+            buf[1] -= '0';
+        }
+    }
+
+    return 0;
+}
+
+static void config_vgt_guest_monitors(void)
+{
+    FILE *monitor_config_f;
+    unsigned char buf[4];
+    vgt_monitor_info_t monitor_configs[MAX_INPUT_NUM];
+    bool text_mode;
+    int input_items;
+    int ret, i;
+
+    if (!vgt_monitor_config_file) {
+        return;
+    }
+
+    if ((monitor_config_f = fopen(vgt_monitor_config_file, "r")) == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d\n",
+            __func__, vgt_monitor_config_file, errno);
+        return;
+    }
+
+    if (get_config_header(buf, monitor_config_f, vgt_monitor_config_file) != 0) {
+        goto finish_config;
+    }
+
+    text_mode = !!buf[0];
+    input_items = buf[1];
+
+    if (input_items <= 0 || input_items > MAX_INPUT_NUM) {
+        qemu_log("vGT: %s, Out of range input of the number of items! "
+            "Should be [1 - 3] but input is %d\n", __func__, input_items);
+        goto finish_config;
+    }
+
+    if (text_mode) {
+        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
+        unsigned char *p = (unsigned char *)monitor_configs;
+        for (i = 0; i < total; ++i, ++p) {
+            unsigned int val = get_byte_from_txt_file(monitor_config_f,
+                vgt_monitor_config_file);
+            if (val == -1) {
+                break;
+            } else {
+                *p = val;
+            }
+        }
+        if (i < total) {
+            goto finish_config;
+        }
+    } else {
+        unsigned int total = sizeof(vgt_monitor_info_t) * input_items;
+        ret = fread(monitor_configs, sizeof(vgt_monitor_info_t), input_items,
+                    monitor_config_f);
+        if (ret != total) {
+            qemu_log("vGT: %s failed to read file %s! "
+                "Expect to read %d bytes but only got %d bytes! errno: %d\n",
+                 __func__, vgt_monitor_config_file, total, ret, errno);
+            goto finish_config;
+        }
+    }
+
+    for (i = 0; i < input_items; ++ i) {
+        if (validate_monitor_configs(&monitor_configs[i]) == false) {
+            qemu_log("vGT: %s the monitor config[%d] input from %s is not valid!\n",
+                __func__, i, vgt_monitor_config_file);
+            goto finish_config;
+        }
+    }
+    for (i = 0; i < input_items; ++ i) {
+        config_hvm_monitors(&monitor_configs[i]);
+    }
+
+finish_config:
+    if (fclose(monitor_config_f) != 0) {
+        qemu_log("vGT: %s failed to close file %s: errno = %d\n", __func__,
+            vgt_monitor_config_file, errno);
+    }
+    return;
+}
+
+/*
+ *  Inform vGT driver to create a vGT instance
+ */
+static void create_vgt_instance(void)
+{
+    /* FIXME: this should be substituded as a environment variable */
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+
+    qemu_log("vGT: %s: domid=%d, low_gm_sz=%dMB, high_gm_sz=%dMB, "
+        "fence_sz=%d, vgt_primary=%d\n", __func__, xen_domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary);
+    if (vgt_low_gm_sz <= 0 || vgt_high_gm_sz <=0 ||
+            vgt_primary < -1 || vgt_primary > 1 ||
+            vgt_fence_sz <=0) {
+        qemu_log("vGT: %s failed: invalid parameters!\n", __func__);
+        abort();
+    }
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        err = errno;
+        qemu_log("vGT: open %s failed\n", path);
+    }
+    /* The format of the string is:
+     * domid,aperture_size,gm_size,fence_size. This means we want the vgt
+     * driver to create a vgt instanc for Domain domid with the required
+     * parameters. NOTE: aperture_size and gm_size are in MB.
+     */
+    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%d\n", xen_domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+
+    config_vgt_guest_monitors();
+}
+
+/*
+ *  Inform vGT driver to close a vGT instance
+ */
+static void destroy_vgt_instance(void)
+{
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+
+    qemu_log("vGT: %s: domid=%d\n", __func__, xen_domid);
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        fprintf(stdout, "vGT: open %s failed\n", path);
+        err = errno;
+    }
+
+    /* -domid means we want the vgt driver to free the vgt instance
+     * of Domain domid.
+     * */
+    if (!err && fprintf(vgt_file, "%d\n", -xen_domid) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s: failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+}
+
+static int pch_map_irq(PCIDevice *pci_dev, int irq_num)
+{
+    return irq_num;
+}
+
+void vgt_bridge_pci_write(PCIDevice *dev, uint32_t addr, uint32_t val, int len)
+{
+#if 0
+    vgt_vga_state_t *o = DO_UPCAST(vgt_vga_state_t, dev, dev);
+#endif
+    assert(dev->devfn == 0x00);
+
+    XEN_PT_LOG(dev, "vGT Config Write: addr=%x len=%x val=%x\n", addr, len, val);
+
+    switch (addr) {
+#if 0
+        case 0x58:        // PAVPC Offset
+            xen_host_pci_set_block(o->host_dev, addr, val, len);
+            break;
+#endif
+        default:
+            pci_default_write_config(dev, addr, val, len);
+    }
+}
+
+static void vgt_bridge_pci_conf_init_from_host(PCIDevice *dev,
+        uint32_t addr, int len)
+{
+    XenHostPCIDevice host_dev;
+
+    if (len > 4) {
+        XEN_PT_LOG(dev, "WARNIGN: length %x too large for config addr %x, ignore init\n",
+                len, addr);
+        return;
+    }
+
+    /* FIXME: need a better scheme to grab the root complex. This
+     * only for a single VM scenario.
+    */
+    if ( xen_host_pci_device_get(&host_dev, 0, 0, 0, 0) < 0) {
+        fprintf(stderr, " Error, failed to get host PCI device\n");
+    }
+
+    xen_host_pci_get_block(&host_dev, addr, dev->config + addr, len);
+    xen_host_pci_device_put(&host_dev);
+}
+
+static void vgt_host_bridge_cap_init(PCIDevice *dev)
+{
+    assert(dev->devfn == 0x00);
+    uint8_t cap_ptr = 0;
+    XenHostPCIDevice host_dev;
+
+    xen_host_pci_device_get(&host_dev, 0, 0, 0, 0);
+    xen_host_pci_get_byte(&host_dev, 0x34, &cap_ptr);
+
+    while (cap_ptr !=0) {
+        vgt_bridge_pci_conf_init_from_host(dev, cap_ptr, 4); /* capability */
+        vgt_bridge_pci_conf_init_from_host(dev, cap_ptr + 4, 4); /* capability */
+        vgt_bridge_pci_conf_init_from_host(dev, cap_ptr + 8, 4); /* capability */
+        vgt_bridge_pci_conf_init_from_host(dev, cap_ptr + 12, 4); /* capability */
+        //XEN_PT_LOG(pci_dev, "Add vgt host bridge capability: offset=0x%x, cap=0x%x\n", cap_ptr,
+        //    pt_pci_host_read(0, PCI_SLOT(pci_dev->devfn), 0, cap_ptr, 1) & 0xFF );
+        xen_host_pci_get_byte(&host_dev, cap_ptr + 1, &cap_ptr);
+    }
+
+    xen_host_pci_device_put(&host_dev);
+}
+
+
+void vgt_bridge_pci_conf_init(PCIDevice *pci_dev)
+{
+    printf("vgt_bridge_pci_conf_init\n");
+    printf("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x00, 2); /* vendor id */
+    printf("vendor id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x00));
+    printf("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x02, 2); /* device id */
+    printf("device id: %x\n", *(uint16_t *)((char *)pci_dev->config + 0x02));
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x06, 2); /* status */
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x08, 2); /* revision id */
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x34, 1); /* capability */
+    vgt_host_bridge_cap_init(pci_dev);
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x50, 2); /* SNB: processor graphics control register */
+    vgt_bridge_pci_conf_init_from_host(pci_dev, 0x52, 2); /* processor graphics control register */
+}
+
+uint32_t vgt_bridge_pci_read(PCIDevice *pci_dev, uint32_t config_addr, int len)
+{
+    uint32_t val;
+
+    val = pci_default_read_config(pci_dev, config_addr, len);
+    XEN_PT_LOG(pci_dev, "addr=%x len=%x val=%x\n", config_addr, len, val);
+
+    return val;
+}
+
+static void vgt_reset(DeviceState *dev)
+{
+}
+
+static void vgt_cleanupfn(PCIDevice *dev)
+{
+    vgt_vga_state_t *d = DO_UPCAST(vgt_vga_state_t, dev, dev);
+
+    if (d->instance_created) {
+        destroy_vgt_instance();
+    }
+}
+
+static int vgt_initfn(PCIDevice *dev)
+{
+    vgt_vga_state_t *d = DO_UPCAST(vgt_vga_state_t, dev, dev);
+
+    printf("vgt_initfn\n");
+    d->instance_created = FALSE;
+
+    create_vgt_instance();
+    return 0;
+}
+
+DeviceState *xengt_vga_init(PCIBus *pci_bus)
+{
+    PCIDevice *dev;
+    XenHostPCIDevice host_dev;
+    PCIBridge *br;
+
+    if (xen_host_pci_device_get(&host_dev, 0, 0, 0x1f, 0) < 0) {
+        fprintf(stderr, " Error, failed to get host PCI device\n");
+        return NULL;
+    }
+
+    if (host_dev.vendor_id != 0x8086) {
+        xen_host_pci_device_put(&host_dev);
+        fprintf(stderr, " Error, vga-xengt is only supported on Intel GPUs\n");
+        return NULL;
+    }
+
+    xen_host_pci_device_put(&host_dev);
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x1f, 0), true,
+                                   "xengt-isa");
+    if (!dev) {
+        fprintf(stderr, "Warning: vga-xengt not available\n");
+        return NULL;
+    }
+
+    qdev_init_nofail(&dev->qdev);
+
+    pci_config_set_vendor_id(dev->config, host_dev.vendor_id);
+    pci_config_set_device_id(dev->config, host_dev.device_id);
+    pci_config_set_revision(dev->config, host_dev.revision_id);
+    pci_config_set_class(dev->config, host_dev.class_code);
+    br = DO_UPCAST(PCIBridge, dev, dev);
+    pci_bridge_map_irq(br, "IGD Bridge",
+                       pch_map_irq);
+
+    printf("Create xengt ISA bridge successfully\n");
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x2, 0), true,
+                                   "xengt-vga");
+    if (!dev) {
+        fprintf(stderr, "Warning: vga-xengt not available\n");
+        return NULL;
+    }
+    qdev_init_nofail(&dev->qdev);
+
+    printf("Create xengt VGA successfully\n");
+    return &dev->qdev;
+}
+
+static void vgt_class_initfn(ObjectClass *klass, void *data)
+{
+    printf("vgt_class_initfn\n");
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    PCIDeviceClass *ic = PCI_DEVICE_CLASS(klass);
+    ic->init = vgt_initfn;
+    dc->reset = vgt_reset;
+    ic->exit = vgt_cleanupfn;
+    dc->vmsd = &vmstate_vga_common;
+}
+
+static TypeInfo vgt_info = {
+    .name          = "xengt-vga",
+    .parent        = TYPE_PCI_DEVICE,
+    .instance_size = sizeof(vgt_vga_state_t),
+    .class_init    = vgt_class_initfn,
+};
+
+static TypeInfo isa_info = {
+    .name          = "xengt-isa",
+    .parent        = TYPE_PCI_DEVICE,
+    .instance_size = sizeof(vgt_vga_state_t),
+};
+
+static void vgt_register_types(void)
+{
+    type_register_static(&vgt_info);
+    type_register_static(&isa_info);
+}
+
+type_init(vgt_register_types)
diff --git a/tools/qemu-xen/hw/vga-xengt.h b/tools/qemu-xen/hw/vga-xengt.h
new file mode 100644
index 0000000..6215ede
--- /dev/null
+++ b/tools/qemu-xen/hw/vga-xengt.h
@@ -0,0 +1,8 @@
+#ifndef __XENGT_H__
+#define __XENGT_H__
+
+DeviceState *xengt_vga_init(PCIBus *pci_bus);
+void vgt_bridge_pci_conf_init(PCIDevice *dev);
+void vgt_bridge_pci_write(PCIDevice *dev, uint32_t addr, uint32_t val, int len);
+uint32_t vgt_bridge_pci_read(PCIDevice *pci_dev, uint32_t config_addr, int len);
+#endif
diff --git a/tools/qemu-xen/hw/vga.c b/tools/qemu-xen/hw/vga.c
index 2b0200a..202cd44 100644
--- a/tools/qemu-xen/hw/vga.c
+++ b/tools/qemu-xen/hw/vga.c
@@ -618,7 +618,14 @@ uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)
     } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {
         val = s->vram_size / (64 * 1024);
     } else {
-        val = 0;
+        switch (s->vbe_index) {
+            case VBE_DISPI_INDEX_LFB_ADDRESS_H:
+                val = VBE_DISPI_LFB_PHYSICAL_ADDRESS >> 16;
+                break;
+            default:
+                val = 0;
+                break;
+        }
     }
 #ifdef DEBUG_BOCHS_VBE
     printf("VBE: read index=0x%x val=0x%x\n", s->vbe_index, val);
diff --git a/tools/qemu-xen/hw/vga_int.h b/tools/qemu-xen/hw/vga_int.h
index bcb738d..03d7741 100644
--- a/tools/qemu-xen/hw/vga_int.h
+++ b/tools/qemu-xen/hw/vga_int.h
@@ -45,6 +45,7 @@
 #define VBE_DISPI_INDEX_Y_OFFSET        0x9
 #define VBE_DISPI_INDEX_NB              0xa /* size of vbe_regs[] */
 #define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa /* read-only, not in vbe_regs */
+#define VBE_DISPI_INDEX_LFB_ADDRESS_H    0xb
 
 #define VBE_DISPI_ID0                   0xB0C0
 #define VBE_DISPI_ID1                   0xB0C1
diff --git a/tools/qemu-xen/hw/xen-host-pci-device.c b/tools/qemu-xen/hw/xen-host-pci-device.c
index 743b37b..16ed13e 100644
--- a/tools/qemu-xen/hw/xen-host-pci-device.c
+++ b/tools/qemu-xen/hw/xen-host-pci-device.c
@@ -378,6 +378,16 @@ int xen_host_pci_device_get(XenHostPCIDevice *d, uint16_t domain,
     d->irq = v;
     d->is_virtfn = xen_host_pci_dev_is_virtfn(d);
 
+    rc = xen_host_pci_get_byte(d, 0x08, &d->revision_id);
+    if (rc) {
+        goto error;
+    }
+
+    rc = xen_host_pci_get_word(d, 0x0a, &d->class_code);
+    if (rc) {
+        goto error;
+    }
+
     return 0;
 error:
     if (d->config_fd >= 0) {
diff --git a/tools/qemu-xen/hw/xen-host-pci-device.h b/tools/qemu-xen/hw/xen-host-pci-device.h
index 0079dac..ee25706 100644
--- a/tools/qemu-xen/hw/xen-host-pci-device.h
+++ b/tools/qemu-xen/hw/xen-host-pci-device.h
@@ -25,6 +25,8 @@ typedef struct XenHostPCIDevice {
 
     uint16_t vendor_id;
     uint16_t device_id;
+    uint8_t revision_id;
+    uint16_t class_code;
     int irq;
 
     XenHostPCIIORegion io_regions[PCI_NUM_REGIONS - 1];
diff --git a/tools/qemu-xen/hw/xen_pt.c b/tools/qemu-xen/hw/xen_pt.c
index 7a3846e..223af3c 100644
--- a/tools/qemu-xen/hw/xen_pt.c
+++ b/tools/qemu-xen/hw/xen_pt.c
@@ -450,6 +450,21 @@ static int xen_pt_register_regions(XenPCIPassthroughState *s)
                    d->rom.size, d->rom.base_addr);
     }
 
+    if (gfx_passthru) {
+        /*
+         * Do not use vendor and class from PCIDevice,
+         * since no one populates them at this time.
+         */
+        uint16_t vendor = pci_get_word(s->dev.config + PCI_VENDOR_ID);
+        uint16_t class = pci_get_word(s->dev.config + PCI_CLASS_DEVICE);
+
+        /* Legacy VGA passthrough. */
+        if (vendor == PCI_VENDOR_ID_INTEL && class == PCI_CLASS_DISPLAY_VGA) {
+            register_vga_regions(&s->dev);
+            setup_vga_pt(&s->dev);
+        }
+    }
+
     return 0;
 }
 
@@ -470,6 +485,14 @@ static void xen_pt_unregister_regions(XenPCIPassthroughState *s)
     if (d->rom.base_addr && d->rom.size) {
         memory_region_destroy(&s->rom);
     }
+
+    if (gfx_passthru) {
+        uint16_t vendor = pci_get_word(s->dev.config + PCI_VENDOR_ID);
+        uint16_t class = pci_get_word(s->dev.config + PCI_CLASS_DEVICE);
+
+        if (vendor == PCI_VENDOR_ID_INTEL && class == PCI_CLASS_DISPLAY_VGA)
+            unregister_vga_regions(&s->dev);
+    }
 }
 
 /* region mapping */
diff --git a/tools/qemu-xen/hw/xen_pt.h b/tools/qemu-xen/hw/xen_pt.h
index f15e69a..aaa0d6b 100644
--- a/tools/qemu-xen/hw/xen_pt.h
+++ b/tools/qemu-xen/hw/xen_pt.h
@@ -298,5 +298,22 @@ static inline bool xen_pt_has_msix_mapping(XenPCIPassthroughState *s, int bar)
     return s->msix && s->msix->bar_index == bar;
 }
 
+extern int gfx_passthru;
+
+uint32_t igd_read_opregion(struct XenHostPCIDevice *dev);
+
+void igd_write_opregion(struct XenHostPCIDevice *dev, uint32_t val);
+
+uint32_t igd_pci_read(PCIDevice *pci_dev, uint32_t config_addr, int len);
+
+void igd_pci_write(PCIDevice *pci_dev, uint32_t config_addr, uint32_t val, int len);
+
+void intel_pch_init(PCIBus *bus);
+
+int setup_vga_pt(struct PCIDevice *dev);
+
+int register_vga_regions(struct PCIDevice *dev);
+
+int unregister_vga_regions(struct PCIDevice *dev);
 
 #endif /* !XEN_PT_H */
diff --git a/tools/qemu-xen/hw/xen_pt_config_init.c b/tools/qemu-xen/hw/xen_pt_config_init.c
index 0a5f82c..dca7136 100644
--- a/tools/qemu-xen/hw/xen_pt_config_init.c
+++ b/tools/qemu-xen/hw/xen_pt_config_init.c
@@ -1438,6 +1438,37 @@ static XenPTRegInfo xen_pt_emu_reg_msix[] = {
     },
 };
 
+static int xen_pt_intel_opregion_read(XenPCIPassthroughState *s,
+		XenPTReg *cfg_entry,
+		uint32_t *value, uint32_t valid_mask)
+{
+	*value = igd_read_opregion(&s->real_device);
+	return 0;
+}
+
+static int xen_pt_intel_opregion_write(XenPCIPassthroughState *s,
+		XenPTReg *cfg_entry,
+		uint32_t *value, uint32_t dev_value,
+		uint32_t valid_mask)
+{
+	igd_write_opregion(&s->real_device, *value);
+	return 0;
+}
+
+static XenPTRegInfo xen_pt_emu_reg_igd_opregion[] = {
+    /* Intel IGFX OpRegion reg */
+    {
+        .offset     = 0x0,
+        .size       = 4,
+        .init_val   = 0,
+        .no_wb      = 1,
+        .u.dw.read   = xen_pt_intel_opregion_read,
+        .u.dw.write  = xen_pt_intel_opregion_write,
+    },
+    {
+        .size = 0,
+    },
+};
 
 /****************************
  * Capabilities
@@ -1675,6 +1706,14 @@ static const XenPTRegGroupInfo xen_pt_emu_reg_grps[] = {
         .size_init   = xen_pt_msix_size_init,
         .emu_regs = xen_pt_emu_reg_msix,
     },
+    /* Intel IGD Opregion group */
+    {
+        .grp_id      = PCI_INTEL_OPREGION,
+        .grp_type    = XEN_PT_GRP_TYPE_EMU,
+        .grp_size    = 0x4,
+        .size_init   = xen_pt_reg_grp_size_init,
+        .emu_regs = xen_pt_emu_reg_igd_opregion,
+    },
     {
         .grp_size = 0,
     },
@@ -1796,6 +1835,10 @@ static int xen_pt_config_reg_init(XenPCIPassthroughState *s,
 
 int xen_pt_config_init(XenPCIPassthroughState *s)
 {
+    uint16_t vendor = pci_get_word(s->dev.config + PCI_VENDOR_ID);
+    uint16_t class = pci_get_word(s->dev.config + PCI_CLASS_DEVICE);
+    int igd_device = !!(vendor == PCI_VENDOR_ID_INTEL && class == PCI_CLASS_DISPLAY_VGA);
+
     int i, rc;
 
     QLIST_INIT(&s->reg_grps);
@@ -1803,8 +1846,15 @@ int xen_pt_config_init(XenPCIPassthroughState *s)
     for (i = 0; xen_pt_emu_reg_grps[i].grp_size != 0; i++) {
         uint32_t reg_grp_offset = 0;
         XenPTRegGroup *reg_grp_entry = NULL;
+        /*
+         * Due to the limitation of XEN PT PCI configuration
+         * emulation routines: assuming the offset of special group
+         * 0xff is always 0. We have to open a new group and add
+         * a small workaround here for OPREGION emulation.
+         */
+        if (xen_pt_emu_reg_grps[i].grp_id != 0xFF
+                && xen_pt_emu_reg_grps[i].grp_id != PCI_INTEL_OPREGION) {
 
-        if (xen_pt_emu_reg_grps[i].grp_id != 0xFF) {
             if (xen_pt_hide_dev_cap(&s->real_device,
                                     xen_pt_emu_reg_grps[i].grp_id)) {
                 continue;
@@ -1817,6 +1867,16 @@ int xen_pt_config_init(XenPCIPassthroughState *s)
             }
         }
 
+        if (xen_pt_emu_reg_grps[i].grp_id == PCI_INTEL_OPREGION) {
+            /*
+             * Do not emulate OPREGION on non-IGD device.
+             */
+            if (!igd_device)
+                continue;
+
+            reg_grp_offset = PCI_INTEL_OPREGION;
+        }
+
         reg_grp_entry = g_new0(XenPTRegGroup, 1);
         QLIST_INIT(&reg_grp_entry->reg_tbl_list);
         QLIST_INSERT_HEAD(&s->reg_grps, reg_grp_entry, entries);
diff --git a/tools/qemu-xen/hw/xen_pt_igd.c b/tools/qemu-xen/hw/xen_pt_igd.c
new file mode 100644
index 0000000..a453216
--- /dev/null
+++ b/tools/qemu-xen/hw/xen_pt_igd.c
@@ -0,0 +1,381 @@
+/*
+ * graphics passthrough
+ */
+#include "xen_pt.h"
+#include "xen-host-pci-device.h"
+#include "xen_backend.h"
+#include "pci_bridge.h"
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <assert.h>
+
+#define D(fmt, args...) \
+	fprintf(stderr, "D [ %lu ] %s() - %d: "fmt"\n", time(NULL), __func__, __LINE__, ##args)
+
+#define E(fmt, args...) \
+	fprintf(stderr, "E [ %lu ] %s() - %d: "fmt"\n", time(NULL), __func__, __LINE__, ##args)
+
+int gfx_passthru;
+
+static uint32_t igd_guest_opregion = 0;
+
+typedef struct {
+	PCIDevice dev;
+} ISABridgeState;
+
+static TypeInfo isa_bridge_info = {
+	.name          = "inte-pch-isa-bridge",
+	.parent        = TYPE_PCI_DEVICE,
+	.instance_size = sizeof(ISABridgeState),
+};
+
+static void xen_pt_graphics_register_types(void)
+{
+	type_register_static(&isa_bridge_info);
+}
+
+type_init(xen_pt_graphics_register_types)
+
+static int create_pch_isa_bridge(PCIBus *bus, XenHostPCIDevice *hdev)
+{
+	struct PCIDevice *dev;
+
+	char rid;
+
+	dev = pci_create(bus, PCI_DEVFN(0x1f, 0), "inte-pch-isa-bridge");
+	if (!dev) {
+		E("fail to create PCH ISA bridge.");
+		return -1;
+	}
+
+	qdev_init_nofail(&dev->qdev);
+
+	pci_config_set_vendor_id(dev->config, hdev->vendor_id);
+	pci_config_set_device_id(dev->config, hdev->device_id);
+
+	xen_host_pci_get_block(hdev, PCI_REVISION_ID, (uint8_t *)&rid, 1);
+
+	pci_config_set_revision(dev->config, rid);
+	pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_ISA);
+
+	D("vid: 0x%x, did: 0x%x rid: 0x%x.", (unsigned int)hdev->vendor_id,
+			(unsigned int)hdev->device_id,
+			(unsigned int)rid);
+
+	return 0;
+}
+
+void intel_pch_init(PCIBus *bus)
+{
+	XenHostPCIDevice hdev;
+	int r;
+
+	D("Called.");
+
+	r = xen_host_pci_device_get(&hdev, 0, 0, 0x1f, 0);
+	if (r) {
+		E("fail to find intel PCH.");
+		goto err;
+	}
+
+	if (hdev.vendor_id == PCI_VENDOR_ID_INTEL) {
+		r = create_pch_isa_bridge(bus, &hdev);
+		if (r) {
+			E("fail to create PCH ISA bridge.");
+			goto err;
+		}
+	}
+
+	xen_host_pci_device_put(&hdev);
+
+	return;
+
+err:
+	E("fail to detect intel PCH.");
+	abort();
+
+	return;
+}
+
+uint32_t igd_read_opregion(struct XenHostPCIDevice *dev)
+{
+	uint32_t val = -1;
+
+	if ( igd_guest_opregion == 0 )
+		return -1;
+
+	val = igd_guest_opregion;
+
+	D("val: 0x%x.", val);
+
+	return val;
+}
+
+void igd_write_opregion(struct XenHostPCIDevice *dev, uint32_t val)
+{
+	uint32_t host_opregion = 0;
+	int ret;
+
+	D("Called.");
+
+	if (igd_guest_opregion) {
+		E("opregion register already been set, ignoring %x\n", val);
+		return;
+	}
+
+	xen_host_pci_get_block(dev, PCI_INTEL_OPREGION, (uint8_t *)&host_opregion, 4);
+	igd_guest_opregion = (val & ~0xfff) | (host_opregion & 0xfff);
+
+	D("Map OpRegion: %x -> %x", host_opregion, igd_guest_opregion);
+
+	ret = xc_domain_memory_mapping(xen_xc, xen_domid,
+			igd_guest_opregion >> XC_PAGE_SHIFT,
+			host_opregion >> XC_PAGE_SHIFT,
+			2,
+			DPCI_ADD_MAPPING);
+
+	if ( ret != 0 )
+	{
+		E("Can't map opregion");
+		igd_guest_opregion = 0;
+	}
+
+	return;
+}
+
+void igd_pci_write(PCIDevice *pci_dev, uint32_t config_addr, uint32_t val, int len)
+{
+	XenHostPCIDevice dev;
+	int r;
+
+	assert(pci_dev->devfn == 0x00);
+
+	D("B W %x %x %x", config_addr, val, len);
+
+	switch (config_addr)
+	{
+		case 0x58:        // PAVPC Offset
+			break;
+		default:
+			goto write_default;
+	}
+
+	/* Host write */
+	r = xen_host_pci_device_get(&dev, 0, 0, 0, 0);
+	if (r) {
+		E("Can't get pci_dev_host_bridge");
+		abort();
+	}
+
+	r = xen_host_pci_set_block(&dev, config_addr, (uint8_t *)&val, len);
+	if (r) {
+		E("Can't get pci_dev_host_bridge");
+		abort();
+	}
+
+	xen_host_pci_device_put(&dev);
+
+	D("addr=%x len=%x val=%x", config_addr, len, val);
+
+	return;
+
+write_default:
+	pci_default_write_config(pci_dev, config_addr, val, len);
+
+	return;
+}
+
+uint32_t igd_pci_read(PCIDevice *pci_dev, uint32_t config_addr, int len)
+{
+	XenHostPCIDevice dev;
+	uint32_t val;
+	int r;
+
+	D("B R %x %x", config_addr, len);
+
+	assert(pci_dev->devfn == 0x00);
+
+	switch (config_addr)
+	{
+		case 0x00:        /* vendor id */
+		case 0x02:        /* device id */
+		case 0x08:        /* revision id */
+		case 0x2c:        /* sybsystem vendor id */
+		case 0x2e:        /* sybsystem id */
+		case 0x50:        /* SNB: processor graphics control register */
+		case 0x52:        /* processor graphics control register */
+		case 0xa0:        /* top of memory */
+		case 0xb0:        /* ILK: BSM: should read from dev 2 offset 0x5c */
+		case 0x58:        /* SNB: PAVPC Offset */
+		case 0xa4:        /* SNB: graphics base of stolen memory */
+		case 0xa8:        /* SNB: base of GTT stolen memory */
+			break;
+		default:
+			goto read_default;
+	}
+
+	/* Host read */
+	r = xen_host_pci_device_get(&dev, 0, 0, 0, 0);
+	if (r) {
+		E("Can't get pci_dev_host_bridge");
+		abort();
+	}
+
+	r = xen_host_pci_get_block(&dev, config_addr, (uint8_t *)&val, len);
+	if (r) {
+		E("Can't get pci_dev_host_bridge");
+		abort();
+	}
+
+	xen_host_pci_device_put(&dev);
+
+	D("B TR %x %x %x", config_addr, val, len);
+
+	return val;
+
+read_default:
+
+	return pci_default_read_config(pci_dev, config_addr, len);
+}
+
+/*
+ * register VGA resources for the domain with assigned gfx
+ */
+int register_vga_regions(struct PCIDevice *dev)
+{
+	int ret = 0;
+
+	ret |= xc_domain_ioport_mapping(xen_xc, xen_domid, 0x3B0,
+			0x3B0, 0xA, DPCI_ADD_MAPPING);
+
+	ret |= xc_domain_ioport_mapping(xen_xc, xen_domid, 0x3C0,
+			0x3C0, 0x20, DPCI_ADD_MAPPING);
+
+	ret |= xc_domain_memory_mapping(xen_xc, xen_domid,
+			0xa0000 >> XC_PAGE_SHIFT,
+			0xa0000 >> XC_PAGE_SHIFT,
+			0x20,
+			DPCI_ADD_MAPPING);
+
+	if (ret != 0)
+		E("VGA region mapping failed");
+
+	return ret;
+}
+
+/*
+ * unregister VGA resources for the domain with assigned gfx
+ */
+int unregister_vga_regions(struct PCIDevice *dev)
+{
+	int ret = 0;
+
+	if ( !gfx_passthru || PCI_DEVICE_GET_CLASS(dev)->class_id != 0x0300 )
+		return ret;
+
+	ret |= xc_domain_ioport_mapping(xen_xc, xen_domid, 0x3B0,
+			0x3B0, 0xC, DPCI_REMOVE_MAPPING);
+
+	ret |= xc_domain_ioport_mapping(xen_xc, xen_domid, 0x3C0,
+			0x3C0, 0x20, DPCI_REMOVE_MAPPING);
+
+	ret |= xc_domain_memory_mapping(xen_xc, xen_domid,
+			0xa0000 >> XC_PAGE_SHIFT,
+			0xa0000 >> XC_PAGE_SHIFT,
+			20,
+			DPCI_REMOVE_MAPPING);
+
+	ret |= xc_domain_memory_mapping(xen_xc, xen_domid,
+			igd_guest_opregion >> XC_PAGE_SHIFT,
+			igd_guest_opregion >> XC_PAGE_SHIFT,
+			2,
+			DPCI_REMOVE_MAPPING);
+
+    if (ret != 0)
+        E("VGA region unmapping failed");
+
+	return ret;
+}
+
+static int get_vgabios(unsigned char *buf)
+{
+    int fd;
+    uint32_t bios_size = 0;
+    uint32_t start = 0xC0000;
+    uint16_t magic = 0;
+
+    if ((fd = open("/dev/mem", O_RDONLY)) < 0) {
+        E("Error: Can't open /dev/mem: %s", strerror(errno));
+        return 0;
+    }
+
+    /*
+     * Check if it a real bios extension.
+     * The magic number is 0xAA55.
+     */
+    if (start != lseek(fd, start, SEEK_SET))
+        goto out;
+    if (read(fd, &magic, 2) != 2)
+        goto out;
+    if (magic != 0xAA55)
+        goto out;
+
+    /* Find the size of the rom extension */
+    if (start != lseek(fd, start, SEEK_SET))
+        goto out;
+    if (lseek(fd, 2, SEEK_CUR) != (start + 2))
+        goto out;
+    if (read(fd, &bios_size, 1) != 1)
+        goto out;
+
+    /* This size is in 512 bytes */
+    bios_size *= 512;
+
+    /*
+     * Set the file to the begining of the rombios,
+     * to start the copy.
+     */
+    if (start != lseek(fd, start, SEEK_SET))
+        goto out;
+
+    if (bios_size != read(fd, buf, bios_size))
+        bios_size = 0;
+
+out:
+    close(fd);
+    return bios_size;
+}
+
+int setup_vga_pt(struct PCIDevice *dev)
+{
+	unsigned char *bios = NULL;
+	int bios_size = 0;
+	char *c = NULL;
+	char checksum = 0;
+	int rc = 0;
+
+	/* Allocated 64K for the vga bios */
+	if (!(bios = malloc(64 * 1024)))
+		return -1;
+
+	bios_size = get_vgabios(bios);
+	if (bios_size == 0 || bios_size > 64 * 1024) {
+		E("vga bios size (0x%x) is invalid!", bios_size);
+		rc = -1;
+		goto out;
+	}
+
+	/* Adjust the bios checksum */
+	for (c = (char*)bios; c < ((char*)bios + bios_size); c++)
+		checksum += *c;
+
+	if (checksum) {
+		bios[bios_size - 1] -= checksum;
+		D("vga bios checksum is adjusted!");
+	}
+
+	cpu_physical_memory_rw(0xc0000, bios, bios_size, 1);
+out:
+	free(bios);
+	return rc;
+}
diff --git a/tools/qemu-xen/qemu-options.hx b/tools/qemu-xen/qemu-options.hx
index de43b1b..0f81370 100644
--- a/tools/qemu-xen/qemu-options.hx
+++ b/tools/qemu-xen/qemu-options.hx
@@ -1003,8 +1003,17 @@ STEXI
 Rotate graphical output some deg left (only PXA LCD).
 ETEXI
 
+DEF("gfx_passthru", 0, QEMU_OPTION_gfx_passthru,
+    "-gfx_passthru   enable Intel IGD passthrough by XEN\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -gfx_passthru
+@findex -gfx_passthru
+Enable Intel IGD passthrough by XEN
+ETEXI
+
 DEF("vga", HAS_ARG, QEMU_OPTION_vga,
-    "-vga [std|cirrus|vmware|qxl|xenfb|none]\n"
+    "-vga [std|cirrus|vmware|qxl|xenfb|xengt|none]\n"
     "                select video card type\n", QEMU_ARCH_ALL)
 STEXI
 @item -vga @var{type}
@@ -1029,11 +1038,51 @@ card.
 QXL paravirtual graphic card.  It is VGA compatible (including VESA
 2.0 VBE support).  Works best with qxl guest drivers installed though.
 Recommended choice when using the spice protocol.
+@item xengt
+Intel IGD card based on mediated pass-through technique. A single
+IGD card can be used to accelerate multiple VMs, which each run
+native graphics driver inside.
 @item none
 Disable VGA card.
 @end table
 ETEXI
 
+DEF("vgt_low_gm_sz", 1, QEMU_OPTION_vgt_low_gm_sz,
+    "-vgt_low_gm_sz [MB] allocated aperture size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_low_gm_sz @var{size}
+@findex -vgt_low_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_high_gm_sz", 1, QEMU_OPTION_vgt_high_gm_sz,
+    "-vgt_high_gm_sz [MB] allocated GM size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_high_gm_sz @var{size}
+@findex -vgt_high_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_fence_sz", 1, QEMU_OPTION_vgt_fence_sz,
+    "-vgt_fence_sz [num] allocated number of fence registers\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_fence_sz @var{size}
+@findex -vgt_fence_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_monitor_config_file", HAS_ARG, QEMU_OPTION_vgt_monitor_config_file,
+    "-vgt_monitor_config_file file Use 'file' to config monitor while creating vgt instance.\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_monitor_config_file @var{file}
+@findex -vgt_monitor_config_file
+Use @var{file} to config monitor while creating vgt instance.
+ETEXI
+
 DEF("full-screen", 0, QEMU_OPTION_full_screen,
     "-full-screen    start in full screen\n", QEMU_ARCH_ALL)
 STEXI
diff --git a/tools/qemu-xen/sysemu.h b/tools/qemu-xen/sysemu.h
index f5ac664..b10a9fc 100644
--- a/tools/qemu-xen/sysemu.h
+++ b/tools/qemu-xen/sysemu.h
@@ -96,12 +96,13 @@ extern int autostart;
 extern int bios_size;
 
 typedef enum {
-    VGA_NONE, VGA_STD, VGA_CIRRUS, VGA_VMWARE, VGA_XENFB, VGA_QXL,
+    VGA_NONE, VGA_STD, VGA_CIRRUS, VGA_VMWARE, VGA_XENFB, VGA_QXL, VGA_XENGT
 } VGAInterfaceType;
 
 extern int vga_interface_type;
 #define xenfb_enabled (vga_interface_type == VGA_XENFB)
 #define qxl_enabled (vga_interface_type == VGA_QXL)
+#define xengt_vga_enabled (vga_interface_type == VGA_XENGT)
 
 extern int graphic_width;
 extern int graphic_height;
diff --git a/tools/qemu-xen/vl.c b/tools/qemu-xen/vl.c
index a3ab384..8df5fb7 100644
--- a/tools/qemu-xen/vl.c
+++ b/tools/qemu-xen/vl.c
@@ -124,6 +124,7 @@ int main(int argc, char **argv)
 #include "hw/watchdog.h"
 #include "hw/smbios.h"
 #include "hw/xen.h"
+#include "hw/xen_pt.h"
 #include "hw/qdev.h"
 #include "hw/loader.h"
 #include "bt-host.h"
@@ -153,7 +154,6 @@ int main(int argc, char **argv)
 #include "fsdev/qemu-fsdev.h"
 #endif
 #include "qtest.h"
-
 #include "disas.h"
 
 #include "qemu_socket.h"
@@ -1848,6 +1848,8 @@ static void select_vgahw (const char *p)
             fprintf(stderr, "Error: standard VGA not available\n");
             exit(0);
         }
+    } else if (strstart(p, "xengt", &opts)) {
+        vga_interface_type = VGA_XENGT;
     } else if (strstart(p, "cirrus", &opts)) {
         if (cirrus_vga_available()) {
             vga_interface_type = VGA_CIRRUS;
@@ -3520,6 +3522,36 @@ int main(int argc, char **argv, char **envp)
             case QEMU_OPTION_object:
                 opts = qemu_opts_parse(qemu_find_opts("object"), optarg, 1);
                 break;
+            case QEMU_OPTION_gfx_passthru:
+                gfx_passthru = 1;
+                break;
+            case QEMU_OPTION_vgt_low_gm_sz:
+                {
+                    extern int vgt_low_gm_sz;
+                    char *ptr;
+                    vgt_low_gm_sz = strtol(optarg,&ptr,10);
+                }
+                break;
+            case QEMU_OPTION_vgt_high_gm_sz:
+                {
+                    extern int vgt_high_gm_sz;
+                    char *ptr;
+                    vgt_high_gm_sz = strtol(optarg,&ptr,10);
+                }
+                break;
+            case QEMU_OPTION_vgt_fence_sz:
+                {
+                    extern int vgt_fence_sz;
+                    char *ptr;
+                    vgt_fence_sz = strtol(optarg,&ptr,10);
+                }
+                break;
+            case QEMU_OPTION_vgt_monitor_config_file:
+                {
+                    extern const char *vgt_monitor_config_file;
+                    vgt_monitor_config_file = optarg;
+                }
+                break;
             default:
                 os_parse_cmd_args(popt->index, optarg);
             }
@@ -3546,6 +3578,11 @@ int main(int argc, char **argv, char **envp)
     }
 #endif
 
+    if (xengt_vga_enabled && gfx_passthru) {
+        fprintf(stderr, "Cannot enable XENGT and VTD at the same time.\n");
+        exit(1);
+    }
+
     if (machine == NULL) {
         fprintf(stderr, "No machine found.\n");
         exit(1);
